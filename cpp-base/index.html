
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://qingjiaotudou.github.io/mysite/cpp-base/">
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../cpp-boost/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.26">
    
    
      
        <title>C++ 基础 - My Docs 我的网站</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#c" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="My Docs 我的网站" class="md-header__button md-logo" aria-label="My Docs 我的网站" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            My Docs 我的网站
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              C++ 基础
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="My Docs 我的网站" class="md-nav__button md-logo" aria-label="My Docs 我的网站" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    My Docs 我的网站
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    欢迎来到MkDocs
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    C++ 基础
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    C++ 基础
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1stringmain" class="md-nav__link">
    <span class="md-ellipsis">
      1、实现一个自定义的String类，保证main函数对正确执行
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2、编写一个类，实现简单的栈。栈中有以下操作：
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3、编写一个类，实现简单的队列。队列中有以下操作：
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-the_holy_bibletxt" class="md-nav__link">
    <span class="md-ellipsis">
      5. 统计一篇英文(The_Holy_Bible.txt)文章中出现的单词和词频
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-log4cpp" class="md-nav__link">
    <span class="md-ellipsis">
      6. 封装log4cpp,使用起来比较方便，如下所示
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7string" class="md-nav__link">
    <span class="md-ellipsis">
      7、实现String类的其它运算符的重载
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8-cowstringoperator" class="md-nav__link">
    <span class="md-ellipsis">
      8. 实现COW的String，让其operator[]能够区分出读写操作
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9tinyxml2rsspagelibdat" class="md-nav__link">
    <span class="md-ellipsis">
      9.使用tinyXml2解析RSS文件，并生成一个网页库pagelib.dat
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10-map" class="md-nav__link">
    <span class="md-ellipsis">
      10. 词频统计的作业再用map容器去实现一次
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    <span class="md-ellipsis">
      11. 文本查询
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12-3750" class="md-nav__link">
    <span class="md-ellipsis">
      12. 两个作业：文本查询扩展(必做)与魔兽世界3750(选做)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13day133" class="md-nav__link">
    <span class="md-ellipsis">
      13、将day13作业中的编程题第3题（文本查询作业）用智能指针的方式再实现一遍，
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14" class="md-nav__link">
    <span class="md-ellipsis">
      14. 实现一个模板形式的单例类
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15-log4cppprintf" class="md-nav__link">
    <span class="md-ellipsis">
      15. 实现log4cpp的封装，使其可以像printf一样使用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16-leetcode-20leetcodeword" class="md-nav__link">
    <span class="md-ellipsis">
      16. Leetcode 20题（见leetcode或word文档）未实现
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17-leetcode-127leetcodeword" class="md-nav__link">
    <span class="md-ellipsis">
      17. Leetcode 127题（见leetcode或word文档）未实现
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18" class="md-nav__link">
    <span class="md-ellipsis">
      18. 使用模板实现一个堆排序算法 未实现
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19" class="md-nav__link">
    <span class="md-ellipsis">
      19. 使用模板实现一个快速排序算法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20-leetcode-146-lurcacheleetcodeword" class="md-nav__link">
    <span class="md-ellipsis">
      20. Leetcode 146 LURCache的实现（见leetcode或word文档）
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#21unordered_mapmap" class="md-nav__link">
    <span class="md-ellipsis">
      21.使用unordered_map/map实现单词转换程序。
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-stdallocatorvector" class="md-nav__link">
    <span class="md-ellipsis">
      22. 了解std::allocator的用法之后,实现自定义的Vector类
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      编程题答案
    </span>
  </a>
  
    <nav class="md-nav" aria-label="编程题答案">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1string" class="md-nav__link">
    <span class="md-ellipsis">
      1、String的实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      2、栈的实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5vector" class="md-nav__link">
    <span class="md-ellipsis">
      5、词频统计vector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7string_1" class="md-nav__link">
    <span class="md-ellipsis">
      7、String运算符重载
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#10mapvector" class="md-nav__link">
    <span class="md-ellipsis">
      10、词频统计map与vector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#11_1" class="md-nav__link">
    <span class="md-ellipsis">
      11、文本查询
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cpp-boost/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++ 提高
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cppsearch/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    C++搜索引擎项目
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1stringmain" class="md-nav__link">
    <span class="md-ellipsis">
      1、实现一个自定义的String类，保证main函数对正确执行
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2、编写一个类，实现简单的栈。栈中有以下操作：
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3、编写一个类，实现简单的队列。队列中有以下操作：
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-the_holy_bibletxt" class="md-nav__link">
    <span class="md-ellipsis">
      5. 统计一篇英文(The_Holy_Bible.txt)文章中出现的单词和词频
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-log4cpp" class="md-nav__link">
    <span class="md-ellipsis">
      6. 封装log4cpp,使用起来比较方便，如下所示
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7string" class="md-nav__link">
    <span class="md-ellipsis">
      7、实现String类的其它运算符的重载
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#8-cowstringoperator" class="md-nav__link">
    <span class="md-ellipsis">
      8. 实现COW的String，让其operator[]能够区分出读写操作
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#9tinyxml2rsspagelibdat" class="md-nav__link">
    <span class="md-ellipsis">
      9.使用tinyXml2解析RSS文件，并生成一个网页库pagelib.dat
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#10-map" class="md-nav__link">
    <span class="md-ellipsis">
      10. 词频统计的作业再用map容器去实现一次
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    <span class="md-ellipsis">
      11. 文本查询
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#12-3750" class="md-nav__link">
    <span class="md-ellipsis">
      12. 两个作业：文本查询扩展(必做)与魔兽世界3750(选做)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#13day133" class="md-nav__link">
    <span class="md-ellipsis">
      13、将day13作业中的编程题第3题（文本查询作业）用智能指针的方式再实现一遍，
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#14" class="md-nav__link">
    <span class="md-ellipsis">
      14. 实现一个模板形式的单例类
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#15-log4cppprintf" class="md-nav__link">
    <span class="md-ellipsis">
      15. 实现log4cpp的封装，使其可以像printf一样使用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#16-leetcode-20leetcodeword" class="md-nav__link">
    <span class="md-ellipsis">
      16. Leetcode 20题（见leetcode或word文档）未实现
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#17-leetcode-127leetcodeword" class="md-nav__link">
    <span class="md-ellipsis">
      17. Leetcode 127题（见leetcode或word文档）未实现
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#18" class="md-nav__link">
    <span class="md-ellipsis">
      18. 使用模板实现一个堆排序算法 未实现
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#19" class="md-nav__link">
    <span class="md-ellipsis">
      19. 使用模板实现一个快速排序算法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#20-leetcode-146-lurcacheleetcodeword" class="md-nav__link">
    <span class="md-ellipsis">
      20. Leetcode 146 LURCache的实现（见leetcode或word文档）
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#21unordered_mapmap" class="md-nav__link">
    <span class="md-ellipsis">
      21.使用unordered_map/map实现单词转换程序。
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#22-stdallocatorvector" class="md-nav__link">
    <span class="md-ellipsis">
      22. 了解std::allocator的用法之后,实现自定义的Vector类
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      编程题答案
    </span>
  </a>
  
    <nav class="md-nav" aria-label="编程题答案">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1string" class="md-nav__link">
    <span class="md-ellipsis">
      1、String的实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      2、栈的实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5vector" class="md-nav__link">
    <span class="md-ellipsis">
      5、词频统计vector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#7string_1" class="md-nav__link">
    <span class="md-ellipsis">
      7、String运算符重载
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#10mapvector" class="md-nav__link">
    <span class="md-ellipsis">
      10、词频统计map与vector
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#11_1" class="md-nav__link">
    <span class="md-ellipsis">
      11、文本查询
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="c">C++ 基础</h1>
<h2 id="1stringmain">1、实现一个自定义的String类，保证main函数对正确执行</h2>
<pre><code class="language-c++">class String
{
public:
    String();
    String(const char *pstr);
    String(const String &amp; rhs);
    String &amp; operator=(const String &amp; rhs);
    ~String();

    void print();

private:
    char * _pstr;
};

int main(void)
{
    String str1;
    str1.print();

    String str2 = &quot;Hello,world&quot;;
    String str3(&quot;wangdao&quot;);

    str2.print();       
    str3.print();   

    String str4 = str3;
    str4.print();

    str4 = str2;
    str4.print();

    return 0;
}
</code></pre>
<h2 id="2">2、编写一个类，实现简单的栈。栈中有以下操作：</h2>
<pre><code class="language-c++">元素入栈     void push(int);
元素出栈     void pop();
读出栈顶元素 int top();
判断栈空     bool emty();
判断栈满     bool full();
如果栈溢出，程序终止。栈的数据成员由存放
10个整型数据的数组构成。先后做如下操作：
创建栈
将10入栈
将12入栈
将14入栈
读出并输出栈顶元素
出栈
读出并输出栈顶元素
</code></pre>
<h2 id="3">3、编写一个类，实现简单的队列。队列中有以下操作：</h2>
<pre><code class="language-c++">元素入队            void push(int);
元素出队            void pop();
读取队头元素         int front();
读取队尾元素         int back();
判断队列是否为空     bool emty();
判断队列是否已满     bool full();
</code></pre>
<h2 id="5-the_holy_bibletxt">5. 统计一篇英文(The_Holy_Bible.txt)文章中出现的单词和词频</h2>
<pre><code class="language-c++">输入：某篇文章的绝对路径
输出：词典（词典中的内容为每一行都是一个“单词 词频”）

词典的存储格式如下
-----------------
|   a 66          |
|   abandon 77    |
|   public 88     |
|    ......       |
|_________________|

struct Record
{
    string _word;
    int _frequency;
};

class Dictionary
{
public:
    //......
    void read(const std::string &amp;filename);
    void store(const std::string &amp;filename);
private:
    vector&lt;Record&gt; _dict;
};
</code></pre>
<h2 id="6-log4cpp">6. 封装log4cpp,使用起来比较方便，如下所示</h2>
<pre><code class="language-c++">输出的日志信息能同时输出到终端和文件

int main(void)
{
    cout &lt;&lt; &quot;hello,world&quot;&lt;&lt;endl;

    logInfo(&quot;Message&quot;); //或者   
    logError(&quot;Message&quot;);
    logWarn(&quot;Message&quot;);
    logDebug(&quot;Message&quot;);
}

加分项：输出的日志信息中最好能有文件的名字，函数的名字及其所在的行号

//使用单例模式
class Mylogger
{
public:
    void warn(const char * msg);
    void error(const char * msg);
    void debug(const char * msg);
    void info(const char * msg);
private:
    Mylogger();
    ~Mylogger();
private:
    //......
};

Mylogger * log = Mylogger::getInstance();
log-&gt;warn(&quot;hello&quot;);
</code></pre>
<h2 id="7string">7、实现String类的其它运算符的重载</h2>
<pre><code class="language-c++">class String 
{
public:
    String();
    String(const char *);
    String(const String&amp;);
    ~String();
    String &amp;operator=(const String &amp;);
    String &amp;operator=(const char *);

    String &amp;operator+=(const String &amp;);
    String &amp;operator+=(const char *);

    char &amp;operator[](std::size_t index);
    const char &amp;operator[](std::size_t index) const;

    std::size_t size() const;
    const char* c_str() const;

    friend bool operator==(const String &amp;, const String &amp;);
    friend bool operator!=(const String &amp;, const String &amp;);

    friend bool operator&lt;(const String &amp;, const String &amp;);
    friend bool operator&gt;(const String &amp;, const String &amp;);
    friend bool operator&lt;=(const String &amp;, const String &amp;);
    friend bool operator&gt;=(const String &amp;, const String &amp;);

    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const String &amp;s);
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, String &amp;s);

private:
    char * _pstr;
};

String operator+(const String &amp;, const String &amp;);
String operator+(const String &amp;, const char *);
String operator+(const char *, const String &amp;);
</code></pre>
<h2 id="8-cowstringoperator">8. 实现COW的String，让其operator[]能够区分出读写操作</h2>
<h2 id="9tinyxml2rsspagelibdat">9.使用tinyXml2解析RSS文件，并生成一个网页库pagelib.dat</h2>
<p>tinyXml2 -- https://github.com/leethomason/tinyxml2</p>
<p>rss      --   https://coolshell.cn/feed</p>
<p>--   http://www.runoob.com/rss/rss-tutorial.html</p>
<pre><code class="language-c++">正则表达式 进行过滤
参考接口:   
struct RssItem
{
    string title;
    string link;
    string description;
    string content;
};

class RssReader
{
public:
    RssReader();
    void parseRss();//解析
    void dump(const string &amp; filename);//输出
private:
    vector&lt;RssItem&gt; _rss;
};   

要求：最后生成一个 pagelib.txt, 其格式:
</code></pre>
<pre><code class="language-c++">    &lt;doc&gt;
      &lt;docid&gt;1&lt;/docid&gt;
      &lt;title&gt; ... &lt;/title&gt;
      &lt;link&gt; ...  &lt;/link&gt;
      &lt;content&gt; ... &lt;/content&gt;
    &lt;/doc&gt;
    &lt;doc&gt;
      ...
    &lt;/doc&gt;
    &lt;doc&gt;
      ...
    &lt;/doc&gt;
</code></pre>
<pre><code class="language-c++">RSS文件解析作业思路：                 
xml --&gt;  rss --&gt; tinyxml2 --&gt; boost::regex/std::regex
</code></pre>
<h2 id="10-map">10. 词频统计的作业再用map容器去实现一次</h2>
<p>体验一下使用vector/map时程序执行的速度++dict[word];</p>
<h2 id="11">11. 文本查询</h2>
<pre><code class="language-c++">该程序将读取用户指定的任意文本文件【当前目录下的china_daily.txt】，
然后允许用户从该文件中查找单词。查询的结果是该单词出现的次数，并列
出每次出现所在的行。如果某单词在同一行中多次出现，程序将只显示该行
一次。行号按升序显示。

要求：
a. 它必须允许用户指明要处理的文件名字。

b. 程序将存储该文件的内容，以便输出每个单词所在的原始行。
vector&lt;string&gt; lines;//O(1) 

c. 它必须将每一行分解为各个单词，并记录每个单词所在的所有行。 
在输出行号时，应保证以升序输出，并且不重复。 

map&lt;string, set&lt;int&gt; &gt; wordNumbers;
map&lt;string, int&gt; dict;

d. 对特定单词的查询将返回出现该单词的所有行的行号。

e. 输出某单词所在的行文本时，程序必须能根据给定的行号从输入
文件中获取相应的行。

示例：
使用提供的文件内容，然后查找单词 &quot;element&quot;。输出的前几行为:
---------------------------------------------
element occurs 125 times.
(line 62) element with a given key.
(line 64) second element with the same key.
(line 153) element |==| operator.
(line 250) the element type.
(line 398) corresponding element.
---------------------------------------------   

程序接口[可选]:
class TextQuery
{
public:
    //......
    void readFile(const string filename);
    //void query(const string &amp; word);//查询和打印耦合在一起了
    QueryResult query(const string &amp; word);
private:
    //......
    vector&lt;string&gt; _lines;//O(1) 
    map&lt;string, set&lt;int&gt; &gt; _wordNumbers;
    map&lt;string, int&gt; _dict;//
};

void print(ostream &amp; os, const QueryResult &amp;);

//程序测试用例
int main(int argc, char *argv[])
{
    string  queryWord(&quot;hello&quot;);

    TextQuery tq;
    tq.readFile(&quot;test.dat&quot;);
    tq.query(queryWord);               
    return 0;
} 
</code></pre>
<h2 id="12-3750">12. 两个作业：文本查询扩展(必做)与魔兽世界3750(选做)</h2>
<p>12、(必做)完成C++ primer(第5版)中的15.9节的文本查询程序扩展</p>
<p>即使不自己实现,最好也要照着书敲一遍代码, 在机器上让程序跑起来.</p>
<p>12.1、(选做)魔兽世界3750: http://bailian.openjudge.cn/practice/3750/</p>
<h2 id="13day133">13、将day13作业中的编程题第3题（文本查询作业）用智能指针的方式再实现一遍，</h2>
<p>可以参考C++ Primer 第5版第12章3小节（12.3）的实现</p>
<h2 id="14">14. 实现一个模板形式的单例类</h2>
<p>要求对于任意类型的类经过Singleton的处理之后，都能获取一个单例对象，并且可以传递任意参数</p>
<pre><code class="language-c++">class Point;
class Computer;

Point pt(1, 2);
Point pt2(3, 4);

Computer com(&quot;Mac&quot;, 8888);


int main(void)
{
    Computer * p1 = Singleton&lt;Computer&gt;::getInstance(&quot;Xiaomi&quot;, 6666);
    Computer * p2 = Singleton&lt;Computer&gt;::getInstance(&quot;Xiaomi&quot;, 6666);

    Point　* p3 = Singleton&lt;Point&gt;::getInstance(1, 2);
    Point　* p4 = Singleton&lt;Point&gt;::getInstance(1, 2);

    Point3D　* p5 = Singleton&lt;Point&gt;::getInstance(1, 2, 3);

    return 0;
} 
</code></pre>
<h2 id="15-log4cppprintf">15. 实现log4cpp的封装，使其可以像printf一样使用</h2>
<p>测试用例如下:</p>
<pre><code class="language-c++">void test() {
    int number = 100;
    const char * pstr = &quot;hello, log4cpp&quot;;
    LogError(&quot;this is an info message. number = %d, str = %s\n&quot;, number, pstr);
}
</code></pre>
<h2 id="16-leetcode-20leetcodeword">16. Leetcode 20题（见leetcode或word文档）未实现</h2>
<h2 id="17-leetcode-127leetcodeword">17. Leetcode 127题（见leetcode或word文档）未实现</h2>
<h2 id="18">18. 使用模板实现一个堆排序算法   未实现</h2>
<p>使用模板的框架如下：</p>
<pre><code class="language-c++">template &lt;typename T, typename Compare = std::less&lt;T&gt; &gt;
class HeapSort
{
public:
    HeapSort(T * arr, int size);        
    void heapAdjust();
    void sort();
private:
    //...
};
</code></pre>
<h2 id="19">19. 使用模板实现一个快速排序算法</h2>
<h2 id="20-leetcode-146-lurcacheleetcodeword">20. Leetcode 146 LURCache的实现（见leetcode或word文档）</h2>
<h2 id="21unordered_mapmap">21.使用unordered_map/map实现单词转换程序。</h2>
<p>给定一个string，将它转换为另一个string。程序的输入是两个文件，第一个文件保存的是一些规则，用来转换第二个文件中的文本。每条规则由两部分组成：一个可能出现在输入文件中的单词和一个用来替换它的短语。表达的含义是，每当第一个单词出现在输入中时，我们就将它替换为对应的短语，第二个输入文件包含要转换的文本。（C++ primer 11.3.6）</p>
<p>提示：
规则文件：map.txt文件，其实就是第一个单词，被后面的一串所替换。
待转换文本：file.txt文件，该文件中的单词如果出现在map.txt文件的第一个单词的话，就用map.txt的后面一串替代。</p>
<p>结果：最后结果其实就是，将file.txt文件中的并且出现在map.txt中第一个单词转换为map.txt后面的一串。例如：where r u的输出结果就是where are you.   r替换为are，u替换为you</p>
<pre><code class="language-txt">//file.txt
where r u
y dont u send me a pic
k thk l8r

//map.txt
brb be right back
k okay?
y why
r are
u you
pic picture
thk thanks!
l8r later 
</code></pre>
<h2 id="22-stdallocatorvector">22. 了解std::allocator的用法之后,实现自定义的Vector类</h2>
<p>接口形式：</p>
<pre><code class="language-c++">template&lt;typename T&gt;
class Vector
{
public:
    Vector();
    ~Vector();

    void push_back(const T &amp;); 
    void pop_back();    

    int size();
    int capacity();
private:
    void reallocate();//重新分配内存,动态扩容要用的
private:    
    static std::allocator&lt;T&gt; _alloc;

    T * _start;      //指向数组中的第一个元素
    T * _finish; //指向最后一个实际元素之后的那个元素
    T * _end_of_storage;        //指向数组本身之后的位置
};
</code></pre>
<pre><code class="language-txt">Vector模型
______________________________
|_|_|_|_|_|____________________|
↑         ↑                    ↑
_start   _finish            _end_of_storage
</code></pre>
<h2 id="_1">编程题答案</h2>
<h3 id="1string">1、String的实现</h3>
<pre><code class="language-c++">/* String.cc */
#include &lt;string.h&gt;
#include &lt;iostream&gt;

using std::cout;
using std::endl;

//面试的题目
class String
{
public:
    String()
    : _pstr(nullptr)
    {
        cout &lt;&lt; &quot;String()&quot; &lt;&lt; endl;
    }
    String(const char *pstr)
    : _pstr(new char[strlen(pstr) + 1]())
    {
        cout &lt;&lt; &quot;String(const char *)&quot; &lt;&lt; endl;
        strcpy(_pstr, pstr);
    }

    String(const String &amp; rhs)
    : _pstr(new char[strlen(rhs._pstr) + 1]())
    {
        cout &lt;&lt; &quot;String(const String &amp;)&quot; &lt;&lt; endl;
        strcpy(_pstr, rhs._pstr);
    }

    String &amp; operator=(const String &amp; rhs)
    {
        cout &lt;&lt; &quot;String &amp;operator=(const String &amp;)&quot; &lt;&lt; endl;
        //1、自复制
        if(this != &amp;rhs)
        {
            //2、释放左操作数
            if(_pstr)
            {
                delete [] _pstr;
                _pstr = nullptr;
            }

            //3、深拷贝
            /* if(rhs._pstr) */
            _pstr = new char[strlen(rhs._pstr) + 1]();
            strcpy(_pstr, rhs._pstr);
        }
        //4、返回*this
        return *this;
    }

    size_t length() const
    {
        size_t len = 0;
        if(_pstr)
        {
            len = strlen(_pstr);
        }

        return len;

    }

    const char * c_str() const
    {
        if(_pstr)
        {
            return _pstr;
        }
        else
        {
            return nullptr;
        }
    }


    ~String()
    {
        cout &lt;&lt; &quot;~String()&quot; &lt;&lt; endl;
        if(_pstr)
        {
            delete [] _pstr;
            _pstr = nullptr;
        }
    }

    void print() const
    {
        if(_pstr)
        {
            cout &lt;&lt; &quot;_pstr = &quot; &lt;&lt; _pstr &lt;&lt; endl;
        }
    }

private:
    char * _pstr;
};

int main(void)
{
    String str1;
    str1.print();

    cout &lt;&lt; endl &lt;&lt; endl;
    //C++         C,&quot;Hello,world&quot;===&gt;String(&quot;Hello,world&quot;)
    String str2 = &quot;Hello,world&quot;;
    String str3(&quot;wangdao&quot;);

    str2.print();       
    str3.print();   

    cout &lt;&lt; endl &lt;&lt; endl;
    String str4 = str3;
    str4.print();

    cout &lt;&lt; endl &lt;&lt; endl;
    str4 = str2;
    str4.print();

    //从C++风格字符串转换为C风格字符串
    const char *pstr = str3.c_str();

    return 0;
}
</code></pre>
<h3 id="2_1">2、栈的实现</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;

using std::cout;
using std::endl;

class Stack
{
public:
    Stack(int size = 10)
    : _size(size)
    , _top(-1)
    , _data(new int[_size]())
    {
        cout &lt;&lt; &quot;Stack(int  = 10)&quot; &lt;&lt; endl;
    }

    ~Stack()
    {
        cout &lt;&lt; &quot;~Satck()&quot; &lt;&lt; endl;
        if(_data)
        {
            delete [] _data;
            _data = nullptr;
        }
    }

    bool full() const
    {
#if 0
        if(_top == _size - 1)
        {
            return true;
        }
        else
        {
            return false;
        }
#endif

        return (_top == _size - 1);
    }

    bool empty() const
    {
        return (-1 == _top);
        /* return ( _top = -1); */
    }

    void push(const int &amp;value)
    {
        if(!full())
        {
            _data[++_top] = value;
        }
        else
        {
            cout &lt;&lt; &quot;The stack is full&quot; &lt;&lt; endl;
            return;
        }
    }
    void pop()
    {
        if(!empty())
        {
            --_top;
        }
        else
        {
            cout &lt;&lt; &quot;The stack is empty&quot; &lt;&lt; endl;
            return;
        }
    }
    int top() const
    {
        return _data[_top];
    }
private:
    int _size;
    int _top;
    int *_data;
};

int main(int argc, char **argv)
{
    Stack st(12);
    cout &lt;&lt; &quot;栈是不是空的？&quot; &lt;&lt; st.empty() &lt;&lt; endl;
    st.push(1);
    cout &lt;&lt; &quot;栈是不是满的？&quot; &lt;&lt; st.full() &lt;&lt; endl;

    for(int idx = 2; idx != 15; ++idx)
    {
        st.push(idx);
    }

    while(!st.empty())
    {
        cout &lt;&lt; st.top() &lt;&lt; endl;
        st.pop();
    }
    cout &lt;&lt; &quot;栈是不是空的？&quot; &lt;&lt; st.empty() &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="5vector">5、词频统计vector</h3>
<pre><code class="language-c++">/* dictVector.cc */
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;

using std::cout;
using std::endl;
using std::cerr;
using std::string;
using std::vector;
using std::ifstream;
using std::ofstream;
using std::istringstream;

struct Record
{
    Record(const string &amp;word, int frequency)
    : _word(word)
    , _frequency(frequency)
    {

    }
    string _word;
    int _frequency;
};

class Dictionary
{
public:
    Dictionary(int capa)
    {
        _dict.reserve(capa);//预留空间
    }

    void read(const string &amp;filename)
    {
        ifstream ifs(filename);
        if(!ifs.good())
        {
            cerr &lt;&lt; &quot;open &quot; &lt;&lt; filename &lt;&lt; &quot; error&quot; &lt;&lt; endl;
            return;
        }
        //读filename这个文件，然后对每一个单词做处理
        string line;
        while(getline(ifs, line))
        {
            //字符串IO
            istringstream iss(line);
            string word;
            while(iss &gt;&gt; word)
            {
                //word一定是最终要保存的单词吗？hello!  1
                string newWord = dealWord(word);//对老的单词做处理，得到新的单词
                insert(newWord);//将满足条件的单词存在vector中
            }
        }

        ifs.close();
    }

    void store(const string &amp;filename)
    {
        ofstream ofs(filename);
        if(!ofs.good())
        {
            cerr &lt;&lt; &quot;open &quot; &lt;&lt; filename &lt;&lt; &quot; error!&quot; &lt;&lt; endl;
            return;
        }

        for(size_t idx = 0; idx != _dict.size(); ++idx)
        {
            ofs &lt;&lt; _dict[idx]._word &lt;&lt; &quot;      &quot; 
                &lt;&lt; _dict[idx]._frequency &lt;&lt; endl;
        }

        ofs.close();
    }

    string dealWord(const string &amp;word)
    {
        for(size_t idx = 0; idx != word.size(); ++idx)
        {
            //word!
            /* if((word[idx] &gt;= 'a'&amp;&amp; word[idx] &lt;= 'z') || (word[idx] &gt;= 'A'&amp;&amp; word[idx] &lt;= 'Z')) */
            if(!isalpha(word[idx]))
            {
                return string();//临时对象
            }
        }

        return word;
    }

    void insert(const string &amp;word)
    {
        //判断空串
        if(word == string())
        {
            return ;
        }

        size_t idx = 0;
        for(idx = 0; idx != _dict.size(); ++idx)
        {
            if(word == _dict[idx]._word)
            {
                ++_dict[idx]._frequency;//频率进行++
                break;
            }
        }

        if(idx == _dict.size())
        {
            _dict.push_back(Record(word, 1));//单词第一次出现的代码
        }
    }

private:
    vector&lt;Record&gt; _dict;
};

int main(int argc, char **argv)
{
    Dictionary dictionary(13000);
    cout &lt;&lt; &quot;begin reading...&quot; &lt;&lt; endl;
    dictionary.read(&quot;The_Holy_Bible.txt&quot;);
    cout &lt;&lt; &quot;end reading...&quot; &lt;&lt; endl;
    dictionary.store(&quot;dict.dat&quot;);
    return 0;
}
</code></pre>
<h3 id="7string_1">7、String运算符重载</h3>
<pre><code class="language-c++">/* stringOperator.cc */
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using std::cout;
using std::endl;
using std::vector;

class String 
{
public:
    String()
   // : _pstr(nullptr)//后面操作的时候，需要判空
    : _pstr(new char[1]())
    {
        cout &lt;&lt; &quot;String()&quot; &lt;&lt; endl;
    }

    //String s1(&quot;hello&quot;)
    //String s1 = &quot;hello&quot;;//String(&quot;hello&quot;)
    //&quot;hello&quot;=====String(&quot;hello&quot;)
    String(const char *pstr)
    : _pstr(new char[strlen(pstr) + 1]())
    {
        cout &lt;&lt; &quot;String(const char *)&quot; &lt;&lt; endl;
        strcpy(_pstr, pstr);
    }

    //String s2(s1);
    //String s2 = s1;
    String(const String &amp;rhs)
    : _pstr(new char[strlen(rhs._pstr) +1]())
    {
        cout &lt;&lt; &quot;String(const String &amp;)&quot; &lt;&lt; endl;
        strcpy(_pstr, rhs._pstr);
    }

    ~String()
    {
        cout &lt;&lt; &quot;~String()&quot; &lt;&lt; endl;
        if(_pstr)
        {
            delete [] _pstr;
            _pstr = nullptr;
        }
    }

    //String s1;
    //s1 = s1;
    String &amp;operator=(const String &amp;rhs)
    {
        cout &lt;&lt; &quot;String &amp;operator=(const String &amp;)&quot; &lt;&lt; endl;
        if(this != &amp;rhs)
        {
            delete [] _pstr;
            _pstr = nullptr;

            _pstr = new char[strlen(rhs._pstr) + 1]();
            strcpy(_pstr, rhs._pstr);
        }
        return  *this;
    }

    // s1 = &quot;hello&quot;;增量开发
    String &amp;operator=(const char *pstr)
    {
        cout &lt;&lt; &quot;String &amp;operator=(const char *)&quot; &lt;&lt; endl;
        String tmp(pstr);
        *this = tmp;

        return *this;
    }

    //s1 += s2;
    String &amp;operator+=(const String &amp;rhs)
    {
        cout &lt;&lt; &quot;String &amp;operator+=(const String &amp;)&quot; &lt;&lt;endl;
        String tmp;
        if(tmp._pstr)
        {
            delete [] tmp._pstr;//防止内存泄漏
        }
        tmp._pstr = new char[strlen(_pstr) + 1]();
        strcpy(tmp._pstr, _pstr);
        delete [] _pstr;
        _pstr = nullptr;
        _pstr = new char[strlen(rhs._pstr) + strlen(tmp._pstr) + 1]();
        strcpy(_pstr, tmp._pstr);
        strcat(_pstr, rhs._pstr);

        return *this;
    }

    //s1 += &quot;hello&quot;
    String &amp;operator+=(const char *pstr)
    {
        cout &lt;&lt; &quot;String &amp;operator+=(const char *)&quot; &lt;&lt; endl;
        String tmp(pstr);
        *this += tmp;

        return *this;
    }

    //const String s1(&quot;helo&quot;);
    //s1[0]
    char &amp;operator[](std::size_t index)//index &gt; = 0
    {
        if(index &lt; size())
        {
            return _pstr[index];
        }
        else
        {
            static char nullchar = '\0';
            return nullchar;
        }
    }

    const char &amp;operator[](std::size_t index) const
    {
        if(index &lt; size())
        {
            return _pstr[index];
        }
        else
        {
            static char nullchar = '\0';
            return nullchar;
        }

    }

    std::size_t size() const
    {
        return strlen(_pstr);
    }

    const char* c_str() const
    {
        return _pstr;
    }

    friend bool operator==(const String &amp;, const String &amp;);
    friend bool operator!=(const String &amp;, const String &amp;);

    friend bool operator&lt;(const String &amp;, const String &amp;);
    friend bool operator&gt;(const String &amp;, const String &amp;);
    friend bool operator&lt;=(const String &amp;, const String &amp;);
    friend bool operator&gt;=(const String &amp;, const String &amp;);

    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const String &amp;s);
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, String &amp;s);

private:
    char * _pstr;
};

bool operator==(const String &amp;lhs, const String &amp;rhs)
{
    return !strcmp(lhs._pstr, rhs._pstr);
}

bool operator!=(const String &amp;lhs, const String &amp;rhs)
{
    return strcmp(lhs._pstr, rhs._pstr);
}

bool operator&lt;(const String &amp;lhs, const String &amp;rhs)
{
    return strcmp(lhs._pstr, rhs._pstr) &lt; 0;
}

bool operator&gt;(const String &amp;lhs, const String &amp;rhs)
{
    return strcmp(lhs._pstr, rhs._pstr) &gt; 0;
}
bool operator&lt;=(const String &amp;lhs, const String &amp;rhs)
{
    return strcmp(lhs._pstr, rhs._pstr) &lt;= 0;
}
bool operator&gt;=(const String &amp;lhs, const String &amp;rhs)
{
    return strcmp(lhs._pstr, rhs._pstr) &gt;= 0;
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const String &amp;rhs)
{
    if(rhs._pstr)
    {
        os &lt;&lt; rhs._pstr;
    }

    return os;
}

//String s1(&quot;hello&quot;)
//cin &gt;&gt; s1;
std::istream &amp;operator&gt;&gt;(std::istream &amp;is, String &amp;rhs)
{
    if(rhs._pstr)
    {
        delete [] rhs._pstr;
        rhs._pstr = nullptr;
    }

    //动态获取从键盘输入数据的长度
    vector&lt;char&gt; buffer;
    char ch;
    while((ch = is.get()) != '\n')
    {
        buffer.push_back(ch);
    }

    rhs._pstr = new char[buffer.size() + 1]();
    strncpy(rhs._pstr, &amp;buffer[0], buffer.size());

    return is;
}

String operator+(const String &amp;lhs, const String &amp;rhs)
{
    cout &lt;&lt; &quot;String operator+(const String &amp;, const String &amp;)&quot; &lt;&lt; endl;

    String tmp(lhs);
    tmp += rhs;

    return tmp;
}
//s1 + &quot;hello&quot;
String operator+(const String &amp;lhs, const char *pstr)
{
    cout &lt;&lt; &quot;String operator+(const String &amp;, const char *)&quot;&lt;&lt; endl;
    String tmp(lhs);
    tmp += pstr;

    return tmp;

}

//&quot;hello&quot; + s1
String operator+(const char *pstr, const String &amp;rhs)
{
    cout &lt;&lt; &quot;String operator+(const char*, const String &amp;)&quot; &lt;&lt; endl;
    String tmp(pstr);
    tmp += rhs;

    return tmp;
}


void test()
{
    String s1;
    /* std::cin &gt;&gt; s1; */
    cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1 &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; endl;
    String s2 = &quot;hello&quot;;
    cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2 &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; &quot;1111&quot; &lt;&lt;  endl;
    s2 = &quot;world&quot;; //error
    cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2 &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; endl;
    s2 = s2;
    cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2 &lt;&lt; endl;

    cout &lt;&lt; endl &lt;&lt; endl;
    String s3 = &quot;wuhan&quot;;
    s3 += &quot; welcome to string word&quot;;
    cout &lt;&lt; &quot;s3 = &quot; &lt;&lt; s3 &lt;&lt; endl;
}

int main(int argc, char **argv)
{
    test();
    return 0;
}
</code></pre>
<h3 id="10mapvector">10、词频统计map与vector</h3>
<p>map：</p>
<pre><code class="language-c++">#include &lt;time.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;utility&gt;

using std::endl;
using std::cerr;
using std::cout;
using std::string;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::map;
using std::pair;

class Dictionary
{
public:
    void read(const string &amp;filename)
    {
        ifstream ifs(filename);
        if(!ifs)
        {
            cerr &lt;&lt; &quot;ifs open &quot; &lt;&lt; filename &lt;&lt; &quot; error!&quot; &lt;&lt; endl;
            return;
        }

        string line;
        while(getline(ifs, line))
        {
            istringstream iss(line);
            string word;
            while(iss &gt;&gt; word)
            {
                string newWord = dealWord(word);
                if(string() != newWord)
                {
                    ++_map[newWord];
                }
            }
        }

        ifs.close();
    }

    void store(const string &amp;filename)
    {
        ofstream ofs(filename);
        if(!ofs)
        {
            cerr &lt;&lt; &quot;ofs open &quot; &lt;&lt; filename &lt;&lt; &quot; error!&quot; &lt;&lt; endl;
            return;
        }

        map&lt;string, int&gt;::iterator it;
        for(it = _map.begin(); it != _map.end(); ++it)
        {
            ofs &lt;&lt; it-&gt;first &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
        }

        ofs.close();
    }
private:
    string dealWord(const string &amp;word)
    {
        //查看获取到的字符串是不是单词：标点符号，true1都不算
        for(size_t idx = 0; idx != word.size(); ++idx)
        {
            if(!isalpha(word[idx]))
            {
                //如果存在标点，数字等不算单词，返回空串
                return string();
            }
        }

        //转换为合理的单词
        return word;
    }

private:
    map&lt;string, int&gt; _map;
};

int main(void)
{
    cout &lt;&lt; &quot;before reading...&quot; &lt;&lt; endl;
    Dictionary dictionary;
    time_t beg = time(NULL);
    dictionary.read(&quot;The_Holy_Bible.txt&quot;);
    time_t end = time(NULL);
    cout &lt;&lt; &quot;time: &quot; &lt;&lt; (end - beg) &lt;&lt; &quot;s&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;aftre reading...&quot; &lt;&lt; endl;
    dictionary.store(&quot;dictMap.dat&quot;);
    return 0;
}
</code></pre>
<p>vector：</p>
<pre><code class="language-c++">#include &lt;time.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;

using std::cout;
using std::cerr;
using std::endl;
using std::string;
using std::vector;
using std::ifstream;
using std::ofstream;
using std::istringstream;
using std::sort;

struct Record
{
    Record(const string &amp;word, int frequency)
    : _word(word)
    , _frequency(frequency)
    {
    }

    string _word;
    int _frequency;
};

bool operator&lt;(const Record &amp;lhs, const Record &amp;rhs)
{
    return lhs._word &lt; rhs._word;
}

class Dictionary
{
public:
    Dictionary(int capa)
    {
        _dict.reserve(capa);
    }

    void read(const string &amp;filename)
    {
        ifstream ifs(filename);
        if(!ifs)//bool operator!(){}  operator bool() {}
        {
            //cout cerr clog
            cerr &lt;&lt; &quot;ifs open file &quot; &lt;&lt; filename &lt;&lt; &quot; error!&quot; &lt;&lt; endl;
            return;
        }

        string line;
        //while(ifs &gt;&gt; word)
        while(getline(ifs, line))
        {
            istringstream iss(line);//串IO，内存
            string word;

            //vector&lt;Point&gt; pt = {Point(1, 2), {3, 4}, (5, 6)};
            //逗号表达式
            while(iss &gt;&gt; word, !iss.eof())//word可能就是不规范abc123
            /* while(iss &gt;&gt; word)//word可能就是不规范abc123,while(真值表达式) iss  ---&gt; bool /int */
            {
                //newWord是处理之后的新单词
                string newWord = dealWord(word);

                //把新的单词插入到vector里面
                insert(newWord);
            }
        }

        //将元素进行排序
        sort(_dict.begin(), _dict.end());

        ifs.close();
    }

    //将单词与词频存储到文件中
    void store(const string &amp;filename)
    {
        ofstream ofs(filename);
        if(!ofs)
        {
            cerr &lt;&lt; &quot;ofs open &quot; &lt;&lt; filename &lt;&lt; &quot; error&quot; &lt;&lt; endl;
            return;
        }

        for(size_t idx = 0; idx != _dict.size(); ++idx)
        {
            ofs &lt;&lt; _dict[idx]._word &lt;&lt; &quot;   &quot; 
                &lt;&lt; _dict[idx]._frequency &lt;&lt; endl;
        }

        ofs.close();
    }

    //对不符合要求的单词进行处理
    string dealWord(const string &amp;word)
    {
        for(size_t idx = 0; idx != word.size(); ++idx)
        {
            //if(word[idx] &gt; 'A')
            if(!isalpha(word[idx]))
            {
                return string();//以空串进行替换
            }
        }

        return word;
    }

    //把结果插入到vector中
    void insert(const string &amp;word)
    {
        if(word == string())
        {
            return;
        }

        size_t idx = 0;
        for(idx = 0; idx != _dict.size(); ++idx)
        {
            if(word == _dict[idx]._word)
            {
                ++_dict[idx]._frequency;
                break;//记得写上
            }
        }

        if(idx == _dict.size())
        {
            _dict.push_back(Record(word, 1));
        }
    }

private:
    vector&lt;Record&gt; _dict;
};

int main(int argc, char **argv)
{
    Dictionary dictionary(13000);
    cout &lt;&lt; &quot;before reading...&quot; &lt;&lt; endl;
    time_t beg = time(NULL);
    dictionary.read(&quot;The_Holy_Bible.txt&quot;);
    time_t end  = time(NULL);
    cout &lt;&lt; &quot;time : &quot; &lt;&lt; (end - beg) &lt;&lt; &quot;s&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;after reading...&quot; &lt;&lt; endl;
    dictionary.store(&quot;dictVector.dat&quot;);
    return 0;
}
</code></pre>
<h3 id="11_1">11、文本查询</h3>
<pre><code class="language-c++">/* TextQuery.cc */
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;

using std::cout;
using std::endl;
using std::cin;
using std::ifstream;
using std::istringstream;
using std::vector;
using std::set;
using std::map;
using std::string;

class TextQuery
{
public:
    //构造函数先分配一定空间的大小
    TextQuery()
    {
        _file.reserve(100);
    }

    void readFile(const string &amp;filename);
    void query(const string &amp;word);

private:
    void preProceccLine(string &amp;line);

private:
    //每次获取一行并存起来
    vector&lt;string&gt; _file;
    //单词以及词频
    map&lt;string, int&gt; _dict;
    //单词以及所在行号(注意：同一个单词在相同行出现，只记录一次)
    map&lt;string, set&lt;int&gt;&gt; _word2line;
};

void TextQuery::readFile(const string &amp;filename)
{
    ifstream ifs(filename);
    if(!ifs)
    {
        cout &lt;&lt; &quot;ifstream open &quot; &lt;&lt; filename &lt;&lt; &quot; error!&quot; &lt;&lt; endl;
        return;
    }

    string line;
    size_t lineNumber = 0;
    while(getline(ifs, line))
    {
        //读一行，并将结果存在vector中(对单词处理前就存起来，存的是原始的)
        _file.push_back(line);

        //对读取行的单词进行处理
        preProceccLine(line);

        istringstream iss(line);
        string word;
        while(iss &gt;&gt; word)
        {
            //统计单词与词频
            ++_dict[word];

            //将单词所在的行记录下来
            _word2line[word].insert(lineNumber);
        }

        ++lineNumber;
    }

    ifs.close();
}

void TextQuery::query(const string &amp;word)
{
    int count = _dict[word];//获取单词出现的次数
    cout &lt;&lt; word &lt;&lt; &quot; occurs &quot; &lt;&lt; count &lt;&lt; (count &gt; 1 ? &quot; times&quot; : &quot; time.&quot;) &lt;&lt; endl;//打印单词次数

    auto lines = _word2line[word];//对同一个单词出现的行进行遍历，输出单词以及行号
    for(auto &amp;number : lines)
    {
        cout &lt;&lt; &quot;    (line &quot; &lt;&lt; number + 1 &lt;&lt; &quot;) &quot; &lt;&lt; _file[number] &lt;&lt; endl;
    }
}

void TextQuery::preProceccLine(string &amp;line)
{
    for(auto &amp;ch : line)
    {
        if(!isalpha(ch))//处理单词，如果不是字母就用空格代替abc? abc123 Hello
        {
            ch = ' ';
        }
        else if(isupper(ch))//如果是大写就转为小写,Hello
        {
            ch = tolower(ch);
        }
    }
}

int main(int argc, char **argv)
{
    TextQuery tq;
    tq.readFile(&quot;china_daily.txt&quot;);
    cout &lt;&lt; &quot; please input a query word: &quot; &lt;&lt; endl;
    string word;
    while(cin &gt;&gt; word)
    {
        tq.query(word);
    }

    return 0;
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../assets/javascripts/bundle.ad660dcc.min.js"></script>
      
    
  </body>
</html>